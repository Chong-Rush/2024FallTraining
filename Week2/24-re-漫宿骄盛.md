通过王爽老师的《汇编语言》（第四版）来学习。

看我博客吧：

<h2 id="1f08c331">一，基础知识：</h2>
<h4 id="150fabae">汇编语言的产生：</h4>
计算机接受的语言是机器语言由0和1组成，但由于机器语言过于难用，所以产生了汇编语言。  
汇编语言（主体为汇编指令）是机器语言（指令）便于记忆的形式

![](https://cdn.nlark.com/yuque/0/2024/png/49936689/1731898311260-830f467d-b854-4033-b088-6b3f47292820.png)

汇编指令通过汇编器转化为机器码，然后被计算机理解和回应。

<h4 id="2230c787">储存器：</h4>
存储器（Memory）是一个广义的概念，它包括了所有用于存储数据的设备。根据其特性和用途，存储器可以分为两大类：主存储器（也称为主存或内存）和辅助存储器（也称为外存或次级存储器）。

<h5 id="dcc691a9">主存储器（内存）</h5>
+ **特点**：速度快，但容量相对较小，且通常是易失性的（断电后数据会丢失）。
+ **类型**： 
    - **RAM (Random Access Memory)**：随机存取存储器，用于存放正在运行的程序和数据。
    - **ROM (Read-Only Memory)**：只读存储器，用于存放固定的、不可更改的数据，如 BIOS。

<h5 id="42aa2c1d">辅助存储器（外存）</h5>
+ **特点**：容量大，速度相对较慢，且通常是非易失性的（断电后数据不会丢失）。
+ **类型**： 
    - **硬盘驱动器 (HDD)**
    - **固态驱动器 (SSD)**
    - **光盘 (CD/DVD/Blu-ray)**
    - **闪存驱动器 (USB闪存盘)**
    - **磁带**

内存重要性仅次于CPU，他与磁盘（外存）不同，CPU可以读取内存中的数据和程序，而不能使用磁盘中的数据和程序，磁盘中的数据和程序想要被使用，必须放在内存里。

<h4 id="a896a97d">汇编指令和数据：</h4>
这是应用上的概念，在内存和磁盘中，他们没有任何区别，都是相同的一串二进制信息，只不过在不同场景下会识别成不同的东西。  
  
疑问：  
怎么判断不同的场景，怎么判断相同的一串东西有不同的作用？

<h4 id="289f98aa">存储器与CPU对存储器的读写：</h4>
存储器是CPU存储数据的地方，有不同的代号（命名）。一个存储器能存多少东西是由他有多少存储单元决定的，一存储单元为1Byte（字节），由8个bit（比特）组成。bit是计算机的最小信息单位，一个bit只能容纳一个0或者1。

CPU读取内存时，首先要将数据的地址通过地址线传到内存，然后通过控制线传输读取内存的命令，最后内存通过数据线将数据传输到CPU。  
CPU写入内存时，也差不多，首先要将数据的地址通过地址线传到内存，然后通过控制线传输写入内存的命令，最后CPU通过数据线将要写入的数据传入到内存。

![](https://cdn.nlark.com/yuque/0/2024/png/49936689/1731898309116-2c50cbbb-ee83-4c14-b46c-a28db2d482e9.png)

![](https://cdn.nlark.com/yuque/0/2024/png/49936689/1731898309127-dac0fe9a-16fd-4dae-8e69-62000d6e47fc.png)

<h4 id="5f34bc78">总线：</h4>
总线便是CPU与内存之间并连的电线，一根线代表一个宽度，可以运输1bit的信息（一个0或者1）。  
线越多，代表宽度越大，传输速度越快。假如你要传输的数据二进制形式超过总线宽度，那这个数据就只能分批传输，而宽度足够大，就能一次性传输。

地址总线的宽度决定了CPU的寻址能力：  
数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量；  
控制总线的宽度决定了CPU对系统中其他器件的控制能力。  
  
一次可以寻找的信息的二进制大小在2^N（电线数）内，比如宽度为8，则最大寻找的信息的大小为2^8。  
  
疑问：  
计算机怎么保证分批传输的是一个数据。

<h2 id="1b6ed56c">二，寄存器：</h2>
之前记的笔记没保存，直接没了……重新再弄吧。



<h3 id="48173696">寄存器的存储：</h3>
寄存器是储存信息的地方。一个寄存器能存多大东西取决于他的位数，即能存多少个0和1。比如一个64位的寄存器则可以储存最大为2^64-1的数 。

高位寄存器可以拆为地位寄存器使用，比如一个16位的寄存器，可以拆成两个8位的使用。

<h3 id="4ec0f6ed">简单汇编语言：</h3>
<h4 id="ac5ca5f1">mov：</h4>
  
mov ax,18 即为向名为ax的寄存器里存入18 等同于 ax= 18  
mov ax,bx 即为将bx的数据存入ax 等同于 ax=bx  
注意：  
这把一个寄存器的数据存入到另一个寄存器一定要保证这两个寄存器的位数都相同,

<h4 id="aa6cc76b">add：</h4>
  
add ax,8 即为将ax中的数据加8 等同于 ax = ax+8  
add ax,bx 即为将bx的数据加到ax上 等同于 ax = ax + bx  
注意：  
相加时也要保证两个寄存器的位数相同。  
add ax,-8 是不能用的  
但可以先给一个寄存器赋值负数，再加到另一个寄存器上

<h4 id="17cf9241">数据溢出：</h4>
当数据相加超出位数时，会发生数据溢出，分为无符号型，有符号型，和浮点型。  
无符号型：  
比如8位寄存器存了一个255，再加一会变成0。  
存了一个0，再减一会变成255。  
有符号型：  
存入127，加一会变成-128。  
存入-128，减一会变成127。  
浮点型：  
会变成正无穷或者负无穷。

<h4 id="d7ca58fa">负数的表示：</h4>
负数为其绝对值二进制去反码再加一，例如：要表示-1，其绝对值二进制00001，取反码：11110,再加一为11111,这就是-1的表示

<h3 id="559a4020">CPU及地址：</h3>
<h4 id="83575bff">CPU：</h4>
CPU为处理数据的核心，其位数决定他能处理多大的数据，比如一块16位的CPU，一次性只能处理一个16位数据。

<h4 id="a3929d66">物理地址及其访问：</h4>
物理地址即为每一个存储单元的地址。

一块CPU能访问的最大地址至于其总线位数有关，与CPU位数无关，CPU位数只影响效率。  
当一个CPU要访问超过其位数的地址，就要采用分段法：  
例如一块16位CPU，20位总线，要访问20位数据，CPU则要提供两个地址，一个为基础地址，和一个偏移地址，将这两个地址，通过一定的运算，则可以得到20位地址。  
当然不一定只能分成两段，还能分的更多，比如一块8位CPU，32位总线，访问32地址，则要分成4段，放到4个8位的寄存器里，然后进行运算得到32位地址。

<h2 id="436cdc9f">三，寄存器（内部访问）:</h2>
<h3 id="d9cb907f">栈：</h3>
书中有一个很形象的例子，栈就像一个盒子一样

![](https://cdn.nlark.com/yuque/0/2024/png/49936689/1731898309876-c756d656-0217-409a-abec-1fe3226f17c8.png)

<h4 id="31ba2489">入栈与出栈：</h4>
汇编提供两个指令push(入栈)，pop（出栈），这两个都是按16字节操作的，要占两个内存单元。

这将10000H~1000FH段内存当作栈来使用，当一个数据存入时从高位1000FH地址向低位10000H地址存放，而出栈却要从低位地址向高位地址取出

<h4 id="54020913">ss:sp</h4>
ss是段寄存器，sp是寄存器，栈的顶部地址（最低位地址，这张图是10000H）存放在SS寄存器中，偏移地址存放在sp中.

任意时刻ss:sp指向栈顶元素

![](https://cdn.nlark.com/yuque/0/2024/png/49936689/1731898312019-ba2463f3-1c21-4ac6-921c-407231341969.png)

<h4 id="c3e9f104">栈的越界：</h4>
比如将110H与120H这段内存当作栈，push8次，占了16个内存单元，SS:SP指向110H，再push一次，就会将10FH与10EH中的元素覆盖

